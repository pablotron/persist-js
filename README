PersistJS 0.1.0 README
======================

Table of Contents
-----------------
  1. Introduction
  2. Rationale
  3. Using PersistJS
  4. Size Limits
  5. Other Limits
  6. Extending PersistJS
  7. API Reference
  8. About the Author

1. Introduction
---------------
PersistJS is a JavaScript client-side persistent storage library.
PersistJS features include:

  * Small (8k minified, 2.5k gzipped)
  * Stand-Alone: No dependencies on other JavaScript libraries or Flash
  * Consistent: Provides a consistent, opaque API.
  * Extensible: Custom backends can be added easily.
  * Backwards Compatible: Can fall back to cookies if no client-side
    storage solution for the given browser is available.
  * Forwards Compatible: Supports the upcoming versions of Internet
    Explorer, Firefox, and Safari.
  * Unobtrusive: Capability testing rather than browser detection, which
    means newer standards-conformant browsers will automatically be
    supported.

The latest version of PersistJS is always available online at the
following URL:

    http://pablotron.org/software/persist-js/

2. Rationale
------------
Why use PersistJS?  What's the problem with cookies or Flash?

Currently the only reliable cross-platform mechanism for storing data
on the client side are cookies.  Unfortunately, using cookies as a
persistent data store has a couple of problems:

  * Size: Cookies are limited to about 4 kilobytes in size.
  * Bandwidth: Cookies are sent along with every HTTP transaction.
  * Complexity: Cookies are difficult to manipulate correctly.

Modern web browsers have addressed these issues by include several
different mechanisms for saving persistent data on the client side.
Unfortunately, each browser has addressed the problem in a different and
incompatible way.  There are currently 4 different client side
persistent data solutions:

  * globalStorage: Firefox 2.0+, Internet Explorer 8
  * localStorage: development WebKit
  * openDatabase: Safari 3.1+
  * userdata behavior: Internet Explorer 5.5+

Some developers have attempted to address this deficiency with browser
plugins:

  * Adobe Flash
  * Google Gears

The problem with relying on Flash and Gears are the same as any other
browser plugin; users without the plugin are stuck, and your application
is tied to software from a particular vendor.  Flash has additional
problems as well:

  * Many users block Flash or require a click in order to enable
    flash content; this makes Flash unsuitable as a transparent,
    client-side data store.
  * Flash is notoriously unreliable on newer 64-bit machines.
  * Some businesses block Flash content as a security measure.

That means there are no less than 6 incompatible solutions for storing
persistent data on the client.  

The most notable attempt at addressing this problem is probably Dojo
Storage.  Unfortunately, Dojo Storage does not support Internet Explorer
without Flash, and it does not support Safari or other WebKit-based
browsers at all.  Also, Dojo Storage is a part of Dojo, which means that
it is not a standalone library; it depends on several other Dojo
components in order to operate.

PersistJS addresses each of these issues.  It currently supports the
following backends:

   * gears:         Google Gears-based persistent storage.
   * localstorage:  HTML5 draft storage.
   * whatwg_db:     HTML5 draft database storage.
   * globalstorage: HTML5 draft storage (old spec).
   * ie:            Internet Explorer userdata behaviors.
   * cookie:        Cookie-based persistent storage.

Each backend provides the exact same interface.  In fact, you don't have
to know or care which backend is being used.  The next section explains
how to use the PersistJS API.

3. Using PersistJS
------------------
Using PersistJS is fairly straightforward.  First, you create a
persistent store object:

    // create new store named "My Application"
    var store = new Persist.Store('My Application');

You can have more than one store, as long as they each have a unique
name.  Store names should begin with a letter, and can consist of upper
and lower case letters, numbers, spaces, and dashes.  

Also, you shouldn't create a persistent store until after the DOM has
loaded.  The easiest browser-agnostic way to do this is to set an
`onload` handler on the `body` element, like this:

    <body onload='load_data();'>

And the JavaScript:

    // global object
    var store;

    function load_data() {
      // load persistent store after the DOM has loaded
      store = new Persist.Store('My Application');
    }

Many JavaScript libraries such as jQuery, YUI, or Prototype have their
own way of adding DOM ready handlers.  Here's how you do it in jQuery:

    $(function() {
      // load persistent store after the DOM has loaded
      store = new Persist.Store('My Application');
    });

After you have created a persistent store, you save values to the
it:

    // save data in store
    store.set('some_key', 'this is a bunch of persistent data');

Note that these values must be strings.  If you want to save structured
data like arrays or hashes, you should serialize it using Array.join or
JSON.

Once you have saved a value to the store, you can read it back, 
like this:

    // get value from store and prompt user
    store.get('some_key', function(ok, val) {
      if (ok)
        alert('some_key = ' + val);
    });

What's up with the anonymous function?  It turns out that some backends
-- specifically the WHATWG Database (used for Safari 3.1) -- only
function asynchronously, so using a callback function is the only
reliable means of ensuring the correct order of operations.  Both
`set()` and `remove()` accept callback functions as well.  Here's an
example of removing a key, then performing an operation afterwards:

    // remove key from store and prompt user
    store.remove('some_key', function(ok, val) {
      // prompt user
      alert('some_key was removed');
    });

If you're in a hurry, then you can stop reading right now, because
that's all you need to know!

Still here?  Okay, here are some additional details.  When you create a
new store, you can also pass a hash of optional parameters, like so:

    // create a new deferred data store with a description
    var store = new Persist.Store('My Data Store', {
      about: 'This is my data store.',
      defer: true
    });

These parameters allow you to pass additional information or fine-tune
the behavior of the data store.  Here's a complete list of the available
parameters:

  * about: Description of this data store (used by `whatwg_db`).
  * defer: Defer saving until `save()` is called (used by `ie`).
  * domain: Limit store to given domain or sub-domain (used by `cookie`
    and `globalstore`).
  * expires: Number of days before store expires (used by `cookie`).
  * path: Limit store to given path (used by `cookie`).
  * size: Estimated size of data set (used by `whatwg_db`).

Notes: The `defer` option exists because there is no way to load and
save individual keys in the `ie` backend.  By default, the `ie` backend
will load all data when getting a value, and save all data when setting
a value.  When the `defer` flag is set, the store data will only be
loaded when the store is created or when the `load()` method is called.  

More importantly, data will _not_ be saved unless the `save()` method is
called.  If you choose to use the `defer` flag, the easiest way to make
sure `save()` is called is to use an unload handler, like so:

    <body unload='save_data();'>

And the JavaScript:

    function save_data() {
      // save store data
      store.save();
    }

It's probably best not to use this feature unless you really need it.

4. Size Limits
--------------
Each backend has a different data size limit.  While you generally
aren't concerned about _which_ backend is being used, you may care about
the amount of data you are able to store.  

To deal with this, the attribute `Persist.size` is set to the
_approximate_ size limit, in bytes, of the active backend.  For backends
where the size limit is unlimited or unknown, `Persist.size` is set to
`-1`.  Here's a rough breakdown of the size limits for each backend:

  * cookie:         4 kilobytes
  * gears:          unknown
  * globalstorage:  5 megabytes
  * ie:             64 kilobytes
  * localstorage:   unknown 
  * whatwg_db:      unknown, although you can request a size with the
                    `size` attribute; defaults to 200 kilobytes

(Note that the key length is also included in the data size limit).

Rather than testing for a specific backend, it is probably better to
calculate the approximate size of the data that you need to save, and
then prompt the user if there is insufficient space.  For example:

    var lots_of_data = '...'; // value with lots of data

    try {
      // check size of data
      if (Persist.size != -1 && Persist.size < lots_of_data.length)
        throw new Error('too much data');

      // try and save data
      store.set('some_key', lots_of_data);
    } catch (err) {
      // display save error
      alert("Couldn't save data: " + err);
    }

5. Other Limits
---------------
The `cookie` backend is limited by the number of maximum number of
cookies that can be saved by the browser.  Older browsers typically
limited the number of cookies to 20 per domain, although newer browsers
have increased this limit to 50 cookies per domain.  

You can work around this limit by serializing your data as JSON or
some other format.

The `cookie` backend is the only backend with any practical limit on the
number of keys.

6. Extending PersistJS
----------------------
TODO...

7. API Reference
----------------
TODO...

8. About the Author
-------------------
Paul Duncan (pabs@pablotron.org)
http://pablotron.org/
